#!/usr/bin/env bash
## File: /usr/local/bin/network-mapping/modules/reports-common.shell

#------------------------------------------------------------------------------#
# Common reporting module for shared and VPC-specific reports
# - Defines environment variables
# - Manages temporary workspace
# - Should be sourced by report scripts, not executed directly
#------------------------------------------------------------------------------#

set -euo pipefail;
## set -x;

export LC_ALL=C;

export TMP_DIR="$( mktemp -d )";
trap '[[ -d "${TMP_DIR}" ]] && rm -rf "${TMP_DIR}"' EXIT;

#------------------------------------------------------------------------------#
# Locate the latest reports folder
#------------------------------------------------------------------------------#

[[ -n ${1:-} ]] && latest_folder="${1}" || {
  echo -e "ERROR: Missing base capture folder path";
  exit 1;
};

shared_folder="${latest_folder}/shared";
exports_folder="exports/${latest_folder}";

mkdir -p "${exports_folder}";

echo -e "Using shared folder: ${shared_folder}";
echo -e "Exporting CSV files to: ${exports_folder}";
echo -e;

#------------------------------------------------------------------------------#
# Report: Network Interfaces - EC2 Instance Interfaces - CSV Output
# Processes ec2_instances.json under each VPC's interfaces/ folder
# Each file contains a list of network interfaces (ENIs) for EC2 instances.
# Extracts:
# - NetworkInterfaceId, PrivateIpAddress, PublicIp, SubnetId, VpcId,
#   Status, Description, InterfaceType, Tags
#
# CSV Columns:
# - VPC
# - NetworkInterfaceId
# - PrivateIpAddress
# - PublicIp
# - SubnetId
# - VpcId
# - Status
# - Description
# - InterfaceType
# - Tags (newline-separated Key=Value pairs)
#------------------------------------------------------------------------------#

function report_interfaces_ec2_instances () {

    local output_file="${exports_folder}/interfaces_ec2_instances.csv";
    : > "${output_file}";

    ## Define the CSV headers as an array
    local headers=(
      VPC
      NetworkInterfaceId
      PrivateIpAddress
      PublicIp
      SubnetId
      VpcId
      Status
      Description
      InterfaceType
      Tags
    ); IFS=','; echo -e "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$( basename "${vpc_path}" )";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      local target_file="${latest_folder}/vpcs/${vpc_folder}/interfaces/ec2_instances.json";
      if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
      fi;

      jq -r --arg vpc "${vpc_folder}" '
        .[] |
        [
          $vpc,
          (.NetworkInterfaceId // "-"),
          (.PrivateIpAddress // "-"),
          (.Association.PublicIp // "-"),
          (.SubnetId // "-"),
          (.VpcId // "-"),
          (.Status // "-"),
          (.Description // "-"),
          (.InterfaceType // "-"),
          (
            ( .TagSet // [] )
            | map( "\(.Key)=\(.Value)" )
            | join( "\n" )
          ) // "-"
        ] | @csv
      ' "${target_file}" | tee -a "${output_file}";
    done;

    return 0;
}; alias report-interfaces-ec2-instances='report_interfaces_ec2_instances';

#------------------------------------------------------------------------------#
# Report: Interfaces - Transit Gateway ENI Attachments - CSV Output
# Processes each transit_gateway_attachments.json file under vpcs/*/interfaces/
# Each file contains a list of network interfaces (ENIs) representing TGW attachments.
# Extracts:
# - NetworkInterfaceId, AttachmentId, Status, SubnetId, VpcId,
#   PrivateIpAddress, InterfaceType, Tags
#
# CSV Columns:
# - VPC
# - NetworkInterfaceId
# - AttachmentId
# - Status
# - SubnetId
# - VpcId
# - PrivateIpAddress
# - InterfaceType
# - Tags (newline-separated Key=Value pairs)
#------------------------------------------------------------------------------#

function report_interfaces_transit_gateway_attachments () {

    local output_file="${exports_folder}/interfaces_transit_gateway_attachments.csv";
    : > "${output_file}";

    ## Define the CSV headers as an array
    local headers=(
      VPC
      NetworkInterfaceId
      AttachmentId
      Status
      SubnetId
      VpcId
      PrivateIpAddress
      InterfaceType
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$(basename "${vpc_path}")";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      local target_file="${latest_folder}/vpcs/${vpc_folder}/interfaces/transit_gateway_attachments.json";
      if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
      fi;

      jq -r --arg vpc "${vpc_folder}" '
        .[]? |
        [
          $vpc,
          (.NetworkInterfaceId // "-"),
          (.Attachment.AttachmentId // "-"),
          (.Status // "-"),
          (.SubnetId // "-"),
          (.VpcId // "-"),
          (.PrivateIpAddress // "-"),
          (.InterfaceType // "-"),
          (
            ( .TagSet // [] )
            | map( "\(.Key)=\(.Value)" )
            | join( "\n" )
          ) // "-"
        ] | @csv
      ' "${target_file}" | tee -a "${output_file}";
    done;

    return 0;
}; alias report-interfaces-transit-gateway-attachments='report_interfaces_transit_gateway_attachments';

#------------------------------------------------------------------------------#
# Report: Interfaces - VPC Endpoint Interfaces - CSV Output
# Processes each vpc_endpoints.json file under vpcs/*/interfaces/
# Each file contains a list of network interfaces (ENIs) representing VPC endpoints.
# Extracts:
# - NetworkInterfaceId, AttachmentId, Description, Status, SubnetId, VpcId,
#   PrivateIpAddress, InterfaceType, Tags
#
# CSV Columns:
# - VPC
# - NetworkInterfaceId
# - AttachmentId
# - Description
# - Status
# - SubnetId
# - VpcId
# - PrivateIpAddress
# - InterfaceType
# - Tags (newline-separated Key=Value pairs)
#------------------------------------------------------------------------------#

function report_interfaces_vpc_endpoints () {

    local output_file="${exports_folder}/interfaces_vpc_endpoints.csv";
    : > "${output_file}";

    ## Define the CSV headers as an array
    local headers=(
      VPC
      NetworkInterfaceId
      AttachmentId
      Description
      Status
      SubnetId
      VpcId
      PrivateIpAddress
      InterfaceType
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$(basename "${vpc_path}")";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      local target_file="${latest_folder}/vpcs/${vpc_folder}/interfaces/vpc_endpoints.json";
      if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
      fi;

      jq -r --arg vpc "${vpc_folder}" '
        .[]? |
        [
          $vpc,
          (.NetworkInterfaceId // "-"),
          (.Attachment.AttachmentId // "-"),
          (.Description // "-"),
          (.Status // "-"),
          (.SubnetId // "-"),
          (.VpcId // "-"),
          (.PrivateIpAddress // "-"),
          (.InterfaceType // "-"),
          (
            ( .TagSet // [] )
            | map( "\(.Key)=\(.Value)" )
            | join( "\n" )
          ) // "-"
        ] | @csv
      ' "${target_file}" | tee -a "${output_file}";
    done;

    return 0;
}; alias report-interfaces-vpc-endpoints='report_interfaces_vpc_endpoints';

#------------------------------------------------------------------------------#
# Report: Interfaces - NAT Gateway Interfaces - CSV Output
# Processes each nat_gateways.json file under vpcs/*/interfaces/
# Each file contains a list of network interfaces (ENIs) representing NAT gateways.
# Extracts:
# - NetworkInterfaceId, AttachmentId, Description, Status, SubnetId, VpcId,
#   PrivateIpAddress, PublicIp, InterfaceType, Tags
#
# CSV Columns:
# - VPC
# - NetworkInterfaceId
# - AttachmentId
# - Description
# - Status
# - SubnetId
# - VpcId
# - PrivateIpAddress
# - PublicIp
# - InterfaceType
# - Tags (newline-separated Key=Value pairs)
#------------------------------------------------------------------------------#

function report_interfaces_nat_gateways () {

    local output_file="${exports_folder}/interfaces_nat_gateways.csv";
    : > "${output_file}";

    ## Define the CSV headers as an array
    local headers=(
      VPC
      NetworkInterfaceId
      AttachmentId
      Description
      Status
      SubnetId
      VpcId
      PrivateIpAddress
      PublicIp
      InterfaceType
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$(basename "${vpc_path}")";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      local target_file="${latest_folder}/vpcs/${vpc_folder}/interfaces/nat_gateways.json";
      if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
      fi;

      jq -r --arg vpc "${vpc_folder}" '
        .[]? |
        [
          $vpc,
          (.NetworkInterfaceId // "-"),
          (.Attachment.AttachmentId // "-"),
          (.Description // "-"),
          (.Status // "-"),
          (.SubnetId // "-"),
          (.VpcId // "-"),
          (.PrivateIpAddress // "-"),
          (.Association.PublicIp // "-"),
          (.InterfaceType // "-"),
          (
            ( .TagSet // [] )
            | map( "\(.Key)=\(.Value)" )
            | join( "\n" )
          ) // "-"
        ] | @csv
      ' "${target_file}" | tee -a "${output_file}";
    done;

    return 0;
}; alias report-interfaces-nat-gateways='report_interfaces_nat_gateways';

#------------------------------------------------------------------------------#
# Report: Subnets - Default Route Tables - CSV Output
# Processes each default_route_tables.json file under vpcs/*/subnets/*/
# Each file contains a list of default routes for the subnet.
# Extracts:
# - DestinationCidrBlock, GatewayId, Origin, State, Tags
#
# CSV Columns:
# - VPC
# - Subnet
# - DestinationCidrBlock
# - GatewayId
# - Origin
# - State
# - Tags (newline-separated Key=Value pairs)
#------------------------------------------------------------------------------#

function report_subnets_default_route_tables () {

    local output_file="${exports_folder}/subnets_default_route_tables.csv";
    : > "${output_file}";

    ## Define the CSV headers as an array
    local headers=(
      VPC
      Subnet
      DestinationCidrBlock
      GatewayId
      Origin
      State
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$( basename "${vpc_path}" )";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      for subnet_path in "${latest_folder}/vpcs/${vpc_folder}/subnets"/*/; do
        local subnet_folder;
        subnet_folder="$( basename "${subnet_path}" )";

        local target_file="${subnet_path}/default_route_tables.json";
        if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
        fi;

        jq -r --arg vpc "${vpc_folder}" --arg subnet "${subnet_folder}" '
          .[]? |
          [
            $vpc,
            $subnet,
            (.DestinationCidrBlock // "-"),
            (.GatewayId // "-"),
            (.Origin // "-"),
            (.State // "-"),
            (
              ( .Tags // [] )
              | map( "\(.Key)=\(.Value)" )
              | join( "\n" )
            ) // "-"
          ] | @csv
        ' "${target_file}" | tee -a "${output_file}";
      done;
    done;

    return 0;
}; alias report-subnets-default-route-tables='report_subnets_default_route_tables';

#------------------------------------------------------------------------------#
# Report: Subnets - EC2 Instances - CSV Output
# Processes each ec2_instances.json file under vpcs/*/subnets/*/
# Each file contains a list of EC2 instances for the subnet.
# Extracts:
# - InstanceId, State, SubnetId, VpcId, PrivateIpAddress, PublicIpAddress,
#   IamRole, SSM PingStatus, PlatformName, Tags
#
# CSV Columns:
# - VPC
# - Subnet
# - InstanceId
# - State
# - SubnetId
# - VpcId
# - PrivateIpAddress
# - PublicIpAddress
# - IamRole
# - SsmPingStatus
# - PlatformName
# - Tags (newline-separated Key=Value pairs)
#------------------------------------------------------------------------------#

function report_subnets_ec2_instances () {

    local output_file="${exports_folder}/subnets_ec2_instances.csv";
    : > "${output_file}";

    ## Define the CSV headers as an array
    local headers=(
      VPC
      Subnet
      InstanceId
      State
      SubnetId
      VpcId
      PrivateIpAddress
      PublicIpAddress
      IamRole
      SsmPingStatus
      PlatformName
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$(basename "${vpc_path}")";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      for subnet_path in "${latest_folder}/vpcs/${vpc_folder}/subnets"/*/; do
        local subnet_folder;
        subnet_folder="$(basename "${subnet_path}")";

        local target_file="${subnet_path}/ec2_instances.json";
        if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
        fi;

        jq -r --arg vpc "${vpc_folder}" --arg subnet "${subnet_folder}" '
          .[]? |
          [
            $vpc,
            $subnet,
            (.InstanceId // "-"),
            (.State // "-"),
            (.SubnetId // "-"),
            (.VpcId // "-"),
            (.PrivateIpAddress // "-"),
            (.PublicIpAddress // "-"),
            (.IamRole // "-"),
            (.SSM.PingStatus // "-"),
            (.SSM.PlatformName // "-"),
            (
              ( .Tags // [] )
              | map( "\(.Key)=\(.Value)" )
              | join( "\n" )
            ) // "-"
          ] | @csv
        ' "${target_file}" | tee -a "${output_file}";
      done;
    done;

    return 0;
}; alias report-subnets-ec2-instances='report_subnets_ec2_instances';

#------------------------------------------------------------------------------#
# Report: Subnets - Subnet Route Tables - CSV Output
# Processes each subnet_route_tables.json file under vpcs/*/subnets/*/
# Each file contains a RouteTables array with Routes and Associations.
# Extracts for each Route:
# - RouteTableId, DestinationCidrBlock, GatewayId, VpcPeeringConnectionId,
#   Origin, State, AssociatedSubnetId, Tags
#
# CSV Columns:
# - VPC
# - Subnet
# - RouteTableId
# - DestinationCidrBlock
# - GatewayId
# - VpcPeeringConnectionId
# - Origin
# - State
# - AssociatedSubnetId
# - Tags (newline-separated Key=Value pairs)
#------------------------------------------------------------------------------#

function report_subnets_subnet_route_tables () {

    local output_file="${exports_folder}/subnets_subnet_route_tables.csv";
    : > "${output_file}";

    ## Define the CSV headers as an array
    local headers=(
      VPC
      Subnet
      RouteTableId
      DestinationCidrBlock
      GatewayId
      VpcPeeringConnectionId
      Origin
      State
      AssociatedSubnetId
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$(basename "${vpc_path}")";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      for subnet_path in "${latest_folder}/vpcs/${vpc_folder}/subnets"/*/; do
        local subnet_folder;
        subnet_folder="$(basename "${subnet_path}")";

        local target_file="${subnet_path}/subnet_route_tables.json";
        if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
        fi;

        jq -r --arg vpc "${vpc_folder}" --arg subnet "${subnet_folder}" '
          .RouteTables[]? as $rtb |
          $rtb.Routes[]? as $route |
          [
            $vpc,
            $subnet,
            ($rtb.RouteTableId // "-"),
            ($route.DestinationCidrBlock // "-"),
            ($route.GatewayId // "-"),
            ($route.VpcPeeringConnectionId // "-"),
            ($route.Origin // "-"),
            ($route.State // "-"),
            ($rtb.Associations[]? | select(.SubnetId != null) | .SubnetId) // "-",
            (
              ( $rtb.Tags // [] )
              | map( "\(.Key)=\(.Value)" )
              | join( "\n" )
            ) // "-"
          ] | @csv
        ' "${target_file}" | tee -a "${output_file}";
      done;
    done;

    return 0;
}; alias report-subnets-subnet-route-tables='report_subnets_subnet_route_tables';

#------------------------------------------------------------------------------#
# Report: Subnets - Subnet Metadata - CSV Output
# Processes each subnet.json file under vpcs/*/subnets/*/
# Each file contains metadata describing a single subnet.
# Extracts:
# - SubnetId, VpcId, CidrBlock, AvailabilityZone, AvailableIpAddressCount,
#   MapPublicIpOnLaunch, DefaultForAz, State, Tags
#
# CSV Columns:
# - VPC
# - Subnet
# - SubnetId
# - VpcId
# - CidrBlock
# - AvailabilityZone
# - AvailableIpAddressCount
# - MapPublicIpOnLaunch
# - DefaultForAz
# - State
# - Tags (newline-separated Key=Value pairs)
#------------------------------------------------------------------------------#

function report_subnets_metadata () {

    local output_file="${exports_folder}/subnets_metadata.csv";
    : > "${output_file}";

    ## Define the CSV headers as an array
    local headers=(
      VPC
      Subnet
      SubnetId
      VpcId
      CidrBlock
      AvailabilityZone
      AvailableIpAddressCount
      MapPublicIpOnLaunch
      DefaultForAz
      State
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$(basename "${vpc_path}")";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      for subnet_path in "${latest_folder}/vpcs/${vpc_folder}/subnets"/*/; do
        local subnet_folder;
        subnet_folder="$(basename "${subnet_path}")";

        local target_file="${subnet_path}/subnet.json";
        if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
        fi;

        jq -r --arg vpc "${vpc_folder}" --arg subnet "${subnet_folder}" '
          [
            $vpc,
            $subnet,
            (.SubnetId // "-"),
            (.VpcId // "-"),
            (.CidrBlock // "-"),
            (.AvailabilityZone // "-"),
            (.AvailableIpAddressCount // "-"),
            (.MapPublicIpOnLaunch | tostring // "-"),
            (.DefaultForAz | tostring // "-"),
            (.State // "-"),
            (
              ( .Tags // [] )
              | map( "\(.Key)=\(.Value)" )
              | join( "\n" )
            ) // "-"
          ] | @csv
        ' "${target_file}" | tee -a "${output_file}";
      done;
    done;

    return 0;
}; alias report-subnets-metadata='report_subnets_metadata';

#------------------------------------------------------------------------------#
# Report Aggregator: DHCP Options across all VPCs - CSV Output
# Scans all folders in ${latest_folder}, excluding "shared" and "exports".
# Processes each vpcs/*/dhcp_options.json file.
#
# Extracts for each DhcpOptions entry:
# - DhcpOptionsId
# - OwnerId
# - Configuration Key
# - Configuration Values (comma-separated)
# - Tags (newline-separated Key=Value pairs)
#
# CSV Columns:
# - VPC
# - DhcpOptionsId
# - OwnerId
# - Key
# - Values
# - Tags
#
# Output file:
# - ${exports_folder}/vpcs_dhcp_options.csv
#------------------------------------------------------------------------------#

function report_vpcs_dhcp_options () {

    local output_file="${exports_folder}/vpcs_dhcp_options.csv";
    : > "${output_file}";

    ## Define the CSV headers as an array
    local headers=(
      VPC
      DhcpOptionsId
      OwnerId
      Key
      Values
      Tags
    ); IFS=','; echo -e "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$( basename "${vpc_path}" )";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      local target_file="${latest_folder}/vpcs/${vpc_folder}/dhcp_options.json";
      if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
      fi;

      jq -r --arg vpc "${vpc_folder}" '
        .DhcpOptions[]? as $opt |
        ($opt.DhcpConfigurations[]? // {}) as $config |
        [
          $vpc,
          ($opt.DhcpOptionsId // "-"),
          ($opt.OwnerId // "-"),
          ($config.Key // "-"),
          (
            ($config.Values // [])
            | map(.Value // "-")
            | join(",")
          ),
          (
            ( $opt.Tags // [] )
            | map( "\(.Key)=\(.Value)" )
            | join( "\n" )
          ) // "-"
        ] | @csv
      ' "${target_file}" | tee -a "${output_file}";
    done;

    return 0;
}; alias report-vpcs-dhcp-options='report_vpcs_dhcp_options';

#------------------------------------------------------------------------------#
# Report Aggregator: Internet Gateways across all VPCs
# Scans all folders in ${latest_folder}, excluding "shared" and "exports"
# Processes each vpc-*/igw.json file
# Each file contains a list of Internet Gateways and their attachments.
# Extracts:
# - InternetGatewayId, OwnerId, AttachmentVpcId, AttachmentState, Tags
#
# CSV Columns:
# - VPC
# - InternetGatewayId
# - OwnerId
# - AttachmentVpcId
# - AttachmentState
# - Tags (newline-separated Key=Value pairs)
#
# Output: vpcs_igws.csv in exports folder
#------------------------------------------------------------------------------#

function report_vpcs_igws () {

    local output_file="${exports_folder}/vpcs_igws.csv";
    : > "${output_file}";

    ## Define the CSV headers as an array
    local headers=(
      VPC
      InternetGatewayId
      OwnerId
      AttachmentVpcId
      AttachmentState
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$( basename "${vpc_path}" )";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      local target_file="${latest_folder}/vpcs/${vpc_folder}/igw.json";
      if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
      fi;

      jq -r --arg vpc "${vpc_folder}" '
        .InternetGateways[]? as $igw |
        ($igw.Attachments[]? // {}) as $attach |
        [
          $vpc,
          ($igw.InternetGatewayId // "-"),
          ($igw.OwnerId // "-"),
          ($attach.VpcId // "-"),
          ($attach.State // "-"),
          (
            ( $igw.Tags // [] )
            | map( "\(.Key)=\(.Value)" )
            | join( "\n" )
          )
        ] | @csv
      ' "${target_file}" | tee -a "${output_file}";
    done;

    return 0;
}; alias report-vpcs-igws='report_vpcs_igws';

#------------------------------------------------------------------------------#
# Report Aggregator: Network ACLs across all VPCs
# Scans all folders in ${latest_folder}, excluding "shared" and "exports"
# Processes each vpc-*/network_acls.json file
# Aggregates into a single CSV:
# - VPC, NetworkAclId, VpcId, OwnerId, IsDefault,
#   AssociationId, AssociatedSubnetId,
#   RuleNumber, Protocol, RuleAction, Egress, CidrBlock, Tags
#
# CSV Columns:
# - VPC
# - NetworkAclId
# - VpcId
# - OwnerId
# - IsDefault
# - AssociationId
# - AssociatedSubnetId
# - RuleNumber
# - Protocol
# - RuleAction
# - Egress
# - CidrBlock
# - Tags (newline-separated Key=Value pairs)
#
# Output: vpcs_network_acls.csv in exports folder
#------------------------------------------------------------------------------#

function report_vpcs_network_acls () {

    local output_file="${exports_folder}/vpcs_network_acls.csv";
    : > "${output_file}";

    ## Define the CSV headers as an array
    local headers=(
      VPC
      NetworkAclId
      VpcId
      OwnerId
      IsDefault
      AssociationId
      AssociatedSubnetId
      RuleNumber
      Protocol
      RuleAction
      Egress
      CidrBlock
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$( basename "${vpc_path}" )";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      local target_file="${latest_folder}/vpcs/${vpc_folder}/network_acls.json";
      if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
      fi;

      jq -r --arg vpc "${vpc_folder}" '
        .NetworkAcls[]? as $acl |
        ($acl.Associations[]? // [{}]) as $assoc |
        ($acl.Entries[]? // [{}]) as $entry |
        [
          $vpc,
          ($acl.NetworkAclId // "-"),
          ($acl.VpcId // "-"),
          ($acl.OwnerId // "-"),
          ($acl.IsDefault | tostring // "-"),
          ($assoc.NetworkAclAssociationId // "-"),
          ($assoc.SubnetId // "-"),
          ($entry.RuleNumber | tostring // "-"),
          ($entry.Protocol // "-"),
          ($entry.RuleAction // "-"),
          ($entry.Egress | tostring // "-"),
          ($entry.CidrBlock // "-"),
          (
            ( $acl.Tags // [] )
            | map( "\(.Key)=\(.Value)" )
            | join( "\n" )
          ) // "-"
        ] | @csv
      ' "${target_file}" | tee -a "${output_file}";
    done;

    return 0;
}; alias report-vpcs-network-acls='report_vpcs_network_acls';

#------------------------------------------------------------------------------#
# Report Aggregator: Network Interfaces across all VPCs
# Scans all folders in ${latest_folder}, excluding "shared" and "exports"
# Processes each vpc-*/network_interfaces.json file
#
# Extracts:
# - NetworkInterfaceId, SubnetId, VpcId, InterfaceType, Status,
#   PrivateIpAddress, PublicIp, MacAddress, Description, OwnerId,
#   AttachmentId, InstanceId, DeviceIndex
# - SecurityGroups: semicolon-separated list of GroupId=GroupName pairs
# - Tags: newline-separated Key=Value pairs
#
# CSV Columns:
# - VPC
# - NetworkInterfaceId
# - SubnetId
# - VpcId
# - InterfaceType
# - Status
# - PrivateIpAddress
# - PublicIp
# - MacAddress
# - Description
# - OwnerId
# - AttachmentId
# - InstanceId
# - DeviceIndex
# - SecurityGroups
# - Tags (newline-separated Key=Value pairs)
#
# Output: vpcs_network_interfaces.csv in exports folder
#------------------------------------------------------------------------------#

function report_vpcs_network_interfaces () {

    local output_file="${exports_folder}/vpcs_network_interfaces.csv";
    : > "${output_file}";

    ## Define the CSV headers as an array
    local headers=(
      VPC
      NetworkInterfaceId
      SubnetId
      VpcId
      InterfaceType
      Status
      PrivateIpAddress
      PublicIp
      MacAddress
      Description
      OwnerId
      AttachmentId
      InstanceId
      DeviceIndex
      SecurityGroups
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$( basename "${vpc_path}" )";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      local target_file="${latest_folder}/vpcs/${vpc_folder}/network_interfaces.json";
      if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
      fi;

      jq -r --arg vpc "${vpc_folder}" '
        .NetworkInterfaces[]? as $eni |
        [
          $vpc,
          ($eni.NetworkInterfaceId // "-"),
          ($eni.SubnetId // "-"),
          ($eni.VpcId // "-"),
          ($eni.InterfaceType // "-"),
          ($eni.Status // "-"),
          ($eni.PrivateIpAddress // "-"),
          ($eni.Association.PublicIp // "-"),
          ($eni.MacAddress // "-"),
          ($eni.Description // "-"),
          ($eni.OwnerId // "-"),
          ($eni.Attachment.AttachmentId // "-"),
          ($eni.Attachment.InstanceId // "-"),
          ($eni.Attachment.DeviceIndex | tostring // "-"),
          (
            ($eni.Groups // [])
            | map("\(.GroupId)=\(.GroupName)")
            | join(";")
          ),
          (
            ( $eni.TagSet // [] )
            | map( "\(.Key)=\(.Value)" )
            | join( "\n" )
          ) // "-"
        ] | @csv
      ' "${target_file}" | tee -a "${output_file}";
    done;

    return 0;
}; alias report-vpcs-network-interfaces='report_vpcs_network_interfaces';

#------------------------------------------------------------------------------#
# Report Aggregator: Unattached Security Groups across all VPCs
# Scans all folders in ${latest_folder}, excluding "shared" and "exports"
# Processes each vpc-*/security_groups_unattached.json file
# Aggregates into a single CSV:
# - VPC, GroupId, GroupName, Description, VpcId, OwnerId, SecurityGroupArn,
#   IngressProtocols, EgressProtocols, Tags
#
# CSV Columns:
# - VPC
# - GroupId
# - GroupName
# - Description
# - VpcId
# - OwnerId
# - SecurityGroupArn
# - IngressProtocols
# - EgressProtocols
# - Tags (newline-separated Key=Value pairs)
#
# Output: vpcs_security_groups_unattached.csv in exports folder
#------------------------------------------------------------------------------#

function report_vpcs_security_groups_unattached () {

    local output_file="${exports_folder}/vpcs_security_groups_unattached.csv";
    : > "${output_file}";

    ## Define the CSV headers as an array
    local headers=(
      VPC
      GroupId
      GroupName
      Description
      VpcId
      OwnerId
      SecurityGroupArn
      IngressProtocols
      EgressProtocols
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$( basename "${vpc_path}" )";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      local target_file="${latest_folder}/vpcs/${vpc_folder}/security_groups_unattached.json";
      if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
      fi;

      jq -r --arg vpc "${vpc_folder}" '
        .[]? as $sg |
        [
          $vpc,
          ($sg.GroupId // "-"),
          ($sg.GroupName // "-"),
          ($sg.Description // "-"),
          ($sg.VpcId // "-"),
          ($sg.OwnerId // "-"),
          ($sg.SecurityGroupArn // "-"),
          (
            ($sg.IpPermissions // [])
            | map(.IpProtocol // "-")
            | unique
            | join(",")
          ),
          (
            ($sg.IpPermissionsEgress // [])
            | map(.IpProtocol // "-")
            | unique
            | join(",")
          ),
          (
            ( $sg.Tags // [] )
            | map( "\(.Key)=\(.Value)" )
            | join( "\n" )
          ) // "-"
        ] | @csv
      ' "${target_file}" | tee -a "${output_file}";
    done;

    return 0;
}; alias report-vpcs-security-groups-unattached='report_vpcs_security_groups_unattached';

#------------------------------------------------------------------------------#
# Report Aggregator: Security Groups across all VPCs
#------------------------------------------------------------------------------
# Processes each VPC-specific security_groups.json file in:
#   <latest_folder>/vpcs/<vpc_name>/security_groups.json
#
# Extracts for each Security Group:
# - VPC:            Folder name representing the VPC
# - GroupId:        Security Group ID
# - GroupName:      Name of the Security Group
# - Description:    Description of the Security Group
# - VpcId:          VPC ID the Security Group belongs to
# - OwnerId:        AWS Account Owner ID
# - SecurityGroupArn: Full ARN of the Security Group
# - IngressRules:   Flattened list of ingress rules in format:
#                   IpProtocol:FromPort-ToPort:CidrIp[,CidrIp,...]
#                   (multiple rules separated by semicolons)
# - EgressRules:    Same format as IngressRules, for egress traffic
# - Tags:           List of tags in "Key=Value" format, separated by newlines
#
# Output CSV:
# - Filename: vpcs_security_groups.csv
# - Location: ${exports_folder}
#------------------------------------------------------------------------------#

function report_vpcs_security_groups () {

    local output_file="${exports_folder}/vpcs_security_groups.csv";
    : > "${output_file}";

    local headers=(
      VPC
      GroupId
      GroupName
      Description
      VpcId
      OwnerId
      SecurityGroupArn
      IngressRules
      EgressRules
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$( basename "${vpc_path}" )";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      local target_file="${latest_folder}/vpcs/${vpc_folder}/security_groups.json";
      if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
      fi;

      jq -r --arg vpc "${vpc_folder}" '
        .SecurityGroups[]? as $sg |
        [
          $vpc,
          ($sg.GroupId // "-"),
          ($sg.GroupName // "-"),
          ($sg.Description // "-"),
          ($sg.VpcId // "-"),
          ($sg.OwnerId // "-"),
          ($sg.SecurityGroupArn // "-"),
          # Ingress rules
          (
            ($sg.IpPermissions // []) | map(
              (.IpProtocol // "-")
              + ":" + ((.FromPort // "-") | tostring)
              + "-" + ((.ToPort // "-") | tostring)
              + ":" + (
                (
                  ((.IpRanges // []) | map(select(type == "object") | .CidrIp // "-"))
                  + ((.Ipv6Ranges // []) | map(select(type == "object") | .CidrIpv6 // "-"))
                  + ((.UserIdGroupPairs // []) | map(select(type == "object") | .GroupId // "-"))
                  + ((.PrefixListIds // []) | map(select(type == "object") | .PrefixListId // "-"))
                ) | join(",")
              )
            ) | join(";")
          ),
          # Egress rules
          (
            ($sg.IpPermissionsEgress // []) | map(
              (.IpProtocol // "-")
              + ":" + ((.FromPort // "-") | tostring)
              + "-" + ((.ToPort // "-") | tostring)
              + ":" + (
                (
                  ((.IpRanges // []) | map(select(type == "object") | .CidrIp // "-"))
                  + ((.Ipv6Ranges // []) | map(select(type == "object") | .CidrIpv6 // "-"))
                  + ((.UserIdGroupPairs // []) | map(select(type == "object") | .GroupId // "-"))
                  + ((.PrefixListIds // []) | map(select(type == "object") | .PrefixListId // "-"))
                ) | join(",")
              )
            ) | join(";")
          ),
          # Tags
          (
            ( $sg.Tags // [] )
            | map( "\(.Key)=\(.Value)" )
            | join( "\n" )
          )
        ] | @csv
      ' "${target_file}" | tee -a "${output_file}";
    done;

    return 0;
}; alias report-vpcs-security-groups='report_vpcs_security_groups';

#------------------------------------------------------------------------------#
# Report Aggregator: EC2 Instances across all VPCs
#------------------------------------------------------------------------------
# Processes each VPC-specific vpc_ec2_instances.json file in:
#   <latest_folder>/vpcs/<vpc_name>/vpc_ec2_instances.json
#
# Extracts for each EC2 instance:
# - VPC:               Folder name representing the VPC
# - InstanceId:        EC2 Instance ID
# - State:             EC2 instance state (running, stopped, etc.)
# - SubnetId:          Subnet ID where the instance resides
# - VpcId:             VPC ID where the instance resides
# - PrivateIpAddress:  Private IPv4 address
# - PublicIpAddress:   Public IPv4 address (if any)
# - IamRole:           IAM Role name (or "-")
# - Tags:              List of tags in "Key=Value" format, separated by newlines
#
# Output CSV:
# - Filename: vpcs_ec2_instances.csv
# - Location: ${exports_folder}
#------------------------------------------------------------------------------#

function report_vpcs_ec2_instances () {

    local output_file="${exports_folder}/vpcs_ec2_instances.csv";
    : > "${output_file}";

    local headers=(
      VPC
      InstanceId
      State
      SubnetId
      VpcId
      PrivateIpAddress
      PublicIpAddress
      IamRole
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$( basename "${vpc_path}" )";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      local target_file="${latest_folder}/vpcs/${vpc_folder}/vpc_ec2_instances.json";
      if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
      fi;

      jq -r --arg vpc "${vpc_folder}" '
        .[]? as $ec2 |
        [
          $vpc,
          ($ec2.InstanceId // "-"),
          ($ec2.State // "-"),
          ($ec2.SubnetId // "-"),
          ($ec2.VpcId // "-"),
          ($ec2.PrivateIpAddress // "-"),
          ($ec2.PublicIpAddress // "-"),
          ($ec2.IamRole // "-"),
          (
            ( $ec2.Tags // [] )
            | map( "\(.Key)=\(.Value)" )
            | join( "\n" )
          )
        ] | @csv
      ' "${target_file}" | tee -a "${output_file}";
    done;

    return 0;
}; alias report-vpcs-ec2-instances='report_vpcs_ec2_instances';

#------------------------------------------------------------------------------#
# Report Aggregator: NAT Gateways across all VPCs
#------------------------------------------------------------------------------
# Processes each VPC-specific vpc_nat_gateways.json file in:
#   <latest_folder>/vpcs/<vpc_name>/vpc_nat_gateways.json
#
# Extracts for each NAT Gateway:
# - VPC:                Folder name representing the VPC
# - NatGatewayId:       NAT Gateway ID
# - State:              NAT Gateway state
# - VpcId:              VPC ID where the NAT Gateway resides
# - SubnetId:           Subnet ID where the NAT Gateway resides
# - ConnectivityType:   Connectivity type (public or private)
# - CreateTime:         Creation timestamp
# - AllocationId:       Elastic IP Allocation ID (from NatGatewayAddresses block)
# - NetworkInterfaceId: Network Interface ID of the NAT Gateway
# - PrivateIp:          Private IP address of the NAT Gateway
# - PublicIp:           Public IP address of the NAT Gateway
# - AssociationId:      Elastic IP Association ID
# - IsPrimary:          Boolean flag indicating if the address is primary
# - AddressStatus:      Status of the NAT Gateway address
# - Tags:               List of tags in "Key=Value" format, separated by newlines
#
# Output CSV:
# - Filename: vpcs_nat_gateways.csv
# - Location: ${exports_folder}
#------------------------------------------------------------------------------#

function report_vpcs_nat_gateways () {

    local output_file="${exports_folder}/vpcs_nat_gateways.csv";
    : > "${output_file}";

    local headers=(
      VPC
      NatGatewayId
      State
      VpcId
      SubnetId
      ConnectivityType
      CreateTime
      AllocationId
      NetworkInterfaceId
      PrivateIp
      PublicIp
      AssociationId
      IsPrimary
      AddressStatus
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$( basename "${vpc_path}" )";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      local target_file="${latest_folder}/vpcs/${vpc_folder}/vpc_nat_gateways.json";
      if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
      fi;

      jq -r --arg vpc "${vpc_folder}" '
        .NatGateways[]? as $nat |
        ($nat.NatGatewayAddresses[]? // [{}]) as $addr |
        [
          $vpc,
          ($nat.NatGatewayId // "-"),
          ($nat.State // "-"),
          ($nat.VpcId // "-"),
          ($nat.SubnetId // "-"),
          ($nat.ConnectivityType // "-"),
          ($nat.CreateTime // "-"),
          ($addr.AllocationId // "-"),
          ($addr.NetworkInterfaceId // "-"),
          ($addr.PrivateIp // "-"),
          ($addr.PublicIp // "-"),
          ($addr.AssociationId // "-"),
          ($addr.IsPrimary | tostring // "-"),
          ($addr.Status // "-"),
          (
            ( $nat.Tags // [] )
            | map( "\(.Key)=\(.Value)" )
            | join( "\n" )
          )
        ] | @csv
      ' "${target_file}" | tee -a "${output_file}";
    done;

    return 0;
}; alias report-vpcs-nat-gateways='report_vpcs_nat_gateways';

#------------------------------------------------------------------------------#
# Report Aggregator: Unassociated VPC Route Tables across all VPCs
#------------------------------------------------------------------------------
# Processes each VPC-specific vpc_route_tables_unassociated.json file in:
#   <latest_folder>/vpcs/<vpc_name>/vpc_route_tables_unassociated.json
#
# Extracts for each Route Table:
# - VPC:                   Folder name representing the VPC
# - RouteTableId:          Route Table ID
# - VpcId:                 VPC ID where the Route Table resides
# - OwnerId:               AWS Account Owner ID
# - AssociationId:         Route Table Association ID
# - AssociationState:      Association state (associated, disassociated)
# - Main:                  Whether this is the main Route Table
# - DestinationCidrBlock:  Route destination CIDR block
# - GatewayId:             Gateway or target of the route
# - Origin:                Route origin (CreateRouteTable, CreateRoute)
# - RouteState:            Route state (active, blackhole)
# - Tags:                  List of tags in "Key=Value" format, separated by newlines
#
# Output CSV:
# - Filename: vpcs_route_tables_unassociated.csv
# - Location: ${exports_folder}
#------------------------------------------------------------------------------#

function report_vpcs_route_tables_unassociated () {

    local output_file="${exports_folder}/vpcs_route_tables_unassociated.csv";
    : > "${output_file}";

    local headers=(
      VPC
      RouteTableId
      VpcId
      OwnerId
      AssociationId
      AssociationState
      Main
      DestinationCidrBlock
      GatewayId
      Origin
      RouteState
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$( basename "${vpc_path}" )";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      local target_file="${latest_folder}/vpcs/${vpc_folder}/vpc_route_tables_unassociated.json";
      if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
      fi;

      jq -r --arg vpc "${vpc_folder}" '
        .[]? as $rtb |
        ($rtb.Associations[]? // [{}]) as $assoc |
        ($rtb.Routes[]? // [{}]) as $route |
        [
          $vpc,
          ($rtb.RouteTableId // "-"),
          ($rtb.VpcId // "-"),
          ($rtb.OwnerId // "-"),
          ($assoc.RouteTableAssociationId // "-"),
          ($assoc.AssociationState.State // "-"),
          ($assoc.Main | tostring // "-"),
          ($route.DestinationCidrBlock // "-"),
          ($route.GatewayId // "-"),
          ($route.Origin // "-"),
          ($route.State // "-"),
          (
            ( $rtb.Tags // [] )
            | map( "\(.Key)=\(.Value)" )
            | join( "\n" )
          )
        ] | @csv
      ' "${target_file}" | tee -a "${output_file}";
    done;

    return 0;
}; alias report-vpcs-route-tables-unassociated='report_vpcs_route_tables_unassociated';

#------------------------------------------------------------------------------#
# Report Aggregator: VPC Route Tables across all VPCs
#------------------------------------------------------------------------------
# Processes each VPC-specific vpc_route_tables.json file in:
#   <latest_folder>/vpcs/<vpc_name>/vpc_route_tables.json
#
# Extracts for each Route Table:
# - VPC:                      Folder name representing the VPC
# - RouteTableId:              Route Table ID
# - VpcId:                     VPC ID
# - OwnerId:                   AWS Account Owner ID
# - AssociationId:             Route Table Association ID
# - AssociationState:          Association state (associated, disassociated)
# - Main:                      Whether this is the main Route Table
# - SubnetId:                  Associated Subnet ID
# - Destination:               Destination CIDR or Prefix List ID
# - GatewayId:                 Gateway target (IGW, NAT, etc.)
# - TransitGatewayId:          Transit Gateway target (if any)
# - VpcPeeringConnectionId:    VPC Peering target (if any)
# - Origin:                    Route origin (CreateRouteTable, CreateRoute)
# - State:                     Route state (active, blackhole)
# - Tags:                      List of tags in "Key=Value" format, separated by newlines
#
# Output CSV:
# - Filename: vpcs_route_tables.csv
# - Location: ${exports_folder}
#------------------------------------------------------------------------------#

function report_vpcs_route_tables () {

    local output_file="${exports_folder}/vpcs_route_tables.csv";
    : > "${output_file}";

    local headers=(
      VPC
      RouteTableId
      VpcId
      OwnerId
      AssociationId
      AssociationState
      Main
      SubnetId
      Destination
      GatewayId
      TransitGatewayId
      VpcPeeringConnectionId
      Origin
      RouteState
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$( basename "${vpc_path}" )";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      local target_file="${latest_folder}/vpcs/${vpc_folder}/vpc_route_tables.json";
      if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
      fi;

      jq -r --arg vpc "${vpc_folder}" '
        .RouteTables[]? as $rtb |
        ($rtb.Associations[]? // [{}]) as $assoc |
        ($rtb.Routes[]? // [{}]) as $route |
        [
          $vpc,
          ($rtb.RouteTableId // "-"),
          ($rtb.VpcId // "-"),
          ($rtb.OwnerId // "-"),
          ($assoc.RouteTableAssociationId // "-"),
          ($assoc.AssociationState.State // "-"),
          ($assoc.Main | tostring // "-"),
          ($assoc.SubnetId // "-"),
          (
            $route.DestinationCidrBlock //
            $route.DestinationPrefixListId // "-"
          ),
          ($route.GatewayId // "-"),
          ($route.TransitGatewayId // "-"),
          ($route.VpcPeeringConnectionId // "-"),
          ($route.Origin // "-"),
          ($route.State // "-"),
          (
            ( $rtb.Tags // [] )
            | map( "\(.Key)=\(.Value)" )
            | join("\n")
          )
        ] | @csv
      ' "${target_file}" | tee -a "${output_file}";
    done;

    return 0;
}; alias report-vpcs-route-tables='report_vpcs_route_tables';

#------------------------------------------------------------------------------#
# Report Aggregator: Transit Gateway Attachments across all VPCs
#------------------------------------------------------------------------------
# Processes each VPC-specific vpc_tgw_attachments.json file in:
#   <latest_folder>/vpcs/<vpc_name>/vpc_tgw_attachments.json
#
# Extracts for each TGW Attachment:
# - VPC:                        Folder name representing the VPC
# - TransitGatewayAttachmentId:  TGW Attachment ID
# - TransitGatewayId:            Transit Gateway ID
# - TransitGatewayOwnerId:       AWS Account ID of the TGW owner
# - ResourceOwnerId:             AWS Account ID of the attachment resource owner
# - ResourceType:                Type of the attached resource (e.g., vpc, vpn)
# - ResourceId:                  ID of the attached resource (e.g., vpc-xxxx)
# - State:                       Attachment state (available, pending, etc.)
# - AssociatedRouteTableId:      Transit Gateway Route Table ID (association)
# - AssociationState:            State of the route table association
# - CreationTime:                Timestamp of attachment creation
# - Tags:                        List of tags in "Key=Value" format, separated by newlines
#
# Output CSV:
# - Filename: vpcs_tgw_attachments.csv
# - Location: ${exports_folder}
#------------------------------------------------------------------------------#

function report_vpcs_transit_gateway_attachments () {

    local output_file="${exports_folder}/vpcs_tgw_attachments.csv";
    : > "${output_file}";

    local headers=(
      VPC
      TransitGatewayAttachmentId
      TransitGatewayId
      TransitGatewayOwnerId
      ResourceOwnerId
      ResourceType
      ResourceId
      State
      AssociatedRouteTableId
      AssociationState
      CreationTime
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$( basename "${vpc_path}" )";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      local target_file="${latest_folder}/vpcs/${vpc_folder}/vpc_tgw_attachments.json";
      if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
      fi;

      jq -r --arg vpc "${vpc_folder}" '
        .TransitGatewayAttachments[]? as $attach |
        [
          $vpc,
          ($attach.TransitGatewayAttachmentId // "-"),
          ($attach.TransitGatewayId // "-"),
          ($attach.TransitGatewayOwnerId // "-"),
          ($attach.ResourceOwnerId // "-"),
          ($attach.ResourceType // "-"),
          ($attach.ResourceId // "-"),
          ($attach.State // "-"),
          ($attach.Association.TransitGatewayRouteTableId // "-"),
          ($attach.Association.State // "-"),
          ($attach.CreationTime // "-"),
          (
            ( $attach.Tags // [] )
            | map( "\(.Key)=\(.Value)" )
            | join("\n")
          )
        ] | @csv
      ' "${target_file}" | tee -a "${output_file}";
    done;

    return 0;
}; alias report-vpcs-transit-gateway-attachments='report_vpcs_transit_gateway_attachments';

#------------------------------------------------------------------------------#
# Report Aggregator: VPC Metadata across all VPCs
#------------------------------------------------------------------------------
# Processes each VPC-specific vpc.json file in:
#   <latest_folder>/vpcs/<vpc_name>/vpc.json
#
# Extracts for each VPC:
# - VPC:                     Folder name representing the VPC
# - VpcId:                   VPC ID
# - State:                   VPC state (available, pending)
# - OwnerId:                 AWS Account Owner ID
# - InstanceTenancy:         VPC tenancy (default/dedicated/host)
# - CidrBlock:               Primary CIDR block
# - DhcpOptionsId:           Associated DHCP Options Set ID
# - IsDefault:               Whether this is the default VPC
# - InternetGatewayBlockMode: IGW Block Mode (enabled/disabled)
# - CidrBlockAssociations:   List of CIDR block associations in the format:
#                            AssociationId=CidrBlock(State);AssociationId=...
# - Tags:                    List of tags in "Key=Value" format, separated by newlines
#
# Output CSV:
# - Filename: vpcs_metadata.csv
# - Location: ${exports_folder}
#------------------------------------------------------------------------------#

function report_vpcs_metadata () {

    local output_file="${exports_folder}/vpcs_metadata.csv";
    : > "${output_file}";

    local headers=(
      VPC
      VpcId
      State
      OwnerId
      InstanceTenancy
      CidrBlock
      DhcpOptionsId
      IsDefault
      InternetGatewayBlockMode
      CidrBlockAssociations
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$( basename "${vpc_path}" )";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      local target_file="${latest_folder}/vpcs/${vpc_folder}/vpc.json";
      if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
      fi;

      jq -r --arg vpc "${vpc_folder}" '
        .Vpcs[]? as $vpc_obj |
        [
          $vpc,
          ($vpc_obj.VpcId // "-"),
          ($vpc_obj.State // "-"),
          ($vpc_obj.OwnerId // "-"),
          ($vpc_obj.InstanceTenancy // "-"),
          ($vpc_obj.CidrBlock // "-"),
          ($vpc_obj.DhcpOptionsId // "-"),
          ($vpc_obj.IsDefault | tostring // "-"),
          ($vpc_obj.BlockPublicAccessStates.InternetGatewayBlockMode // "-"),
          (
            ($vpc_obj.CidrBlockAssociationSet // [])
            | map(
              (.AssociationId // "-") + "=" + (.CidrBlock // "-") + "(" + (.CidrBlockState.State // "-") + ")"
            )
            | join(";")
          ),
          (
            ( $vpc_obj.Tags // [] )
            | map( "\(.Key)=\(.Value)" )
            | join( "\n" )
          )
        ] | @csv
      ' "${target_file}" | tee -a "${output_file}";
    done;

    return 0;
}; alias report-vpcs-metadata='report_vpcs_metadata';

#------------------------------------------------------------------------------#
# Report Aggregator: VPC Endpoints across all VPCs
#------------------------------------------------------------------------------
# Processes each VPC-specific vpc_endpoints.json file in:
#   <latest_folder>/vpcs/<vpc_name>/vpc_endpoints.json
#
# Extracts for each VPC Endpoint:
# - VPC:                  Folder name representing the VPC
# - VpcEndpointId:        VPC Endpoint ID
# - VpcEndpointType:      Endpoint type (Interface, Gateway, etc.)
# - VpcId:                VPC ID
# - ServiceName:          AWS service name
# - ServiceRegion:        Region of the service
# - State:                Endpoint state (available, pending, etc.)
# - PrivateDnsEnabled:    Whether Private DNS is enabled
# - RequesterManaged:     Whether requester manages this endpoint
# - IpAddressType:        Address type (IPv4, DualStack, etc.)
# - CreationTimestamp:    Creation time
# - RouteTableIds:        Associated Route Table IDs (comma-separated)
# - SubnetIds:            Associated Subnet IDs (comma-separated)
# - NetworkInterfaceIds:  ENI IDs (comma-separated)
# - Groups:               List of groups as GroupId=GroupName pairs (semicolon-separated)
# - DnsEntries:           List of DNS entries as DnsName=HostedZoneId pairs (semicolon-separated)
# - Tags:                 List of tags in "Key=Value" format, separated by newlines
#
# Output CSV:
# - Filename: vpcs_endpoints.csv
# - Location: ${exports_folder}
#------------------------------------------------------------------------------#

function report_vpcs_endpoints () {

    local output_file="${exports_folder}/vpcs_endpoints.csv";
    : > "${output_file}";

    local headers=(
      VPC
      VpcEndpointId
      VpcEndpointType
      VpcId
      ServiceName
      ServiceRegion
      State
      PrivateDnsEnabled
      RequesterManaged
      IpAddressType
      CreationTimestamp
      RouteTableIds
      SubnetIds
      NetworkInterfaceIds
      Groups
      DnsEntries
      Tags
    ); IFS=','; echo "${headers[*]}" > "${output_file}";

    for vpc_path in "${latest_folder}/vpcs"/*/; do
      local vpc_folder;
      vpc_folder="$( basename "${vpc_path}" )";

      [[ "${vpc_folder}" == "shared" ]] && continue;
      [[ "${vpc_folder}" == "exports" ]] && continue;

      local target_file="${latest_folder}/vpcs/${vpc_folder}/vpc_endpoints.json";
      if [[ ! -f "${target_file}" ]]; then
              # echo -e "Skipping: ${target_file} not found";
              continue;
        else  echo -e "\nProcessing: ${target_file}";
      fi;

      jq -r --arg vpc "${vpc_folder}" '
        .VpcEndpoints[]? as $ep |
        [
          $vpc,
          ($ep.VpcEndpointId // "-"),
          ($ep.VpcEndpointType // "-"),
          ($ep.VpcId // "-"),
          ($ep.ServiceName // "-"),
          ($ep.ServiceRegion // "-"),
          ($ep.State // "-"),
          ($ep.PrivateDnsEnabled | tostring // "-"),
          ($ep.RequesterManaged | tostring // "-"),
          ($ep.IpAddressType // "-"),
          ($ep.CreationTimestamp // "-"),
          (
            ($ep.RouteTableIds // [])
            | join(",")
          ),
          (
            ($ep.SubnetIds // [])
            | join(",")
          ),
          (
            ($ep.NetworkInterfaceIds // [])
            | join(",")
          ),
          (
            ($ep.Groups // [])
            | map("\(.GroupId)=\(.GroupName)")
            | join(";")
          ),
          (
            ($ep.DnsEntries // [])
            | map("\(.DnsName)=\(.HostedZoneId)")
            | join(";")
          ),
          (
            ( $ep.Tags // [] )
            | map( "\(.Key)=\(.Value)" )
            | join( "\n" )
          )
        ] | @csv
      ' "${target_file}" | tee -a "${output_file}";
    done;

    return 0;
}; alias report-vpcs-endpoints='report_vpcs_endpoints';

#------------------------------------------------------------------------------#

report_interfaces_ec2_instances; echo -e;
report_interfaces_nat_gateways; echo -e;
report_interfaces_transit_gateway_attachments; echo -e;
report_interfaces_vpc_endpoints; echo -e;
report_subnets_default_route_tables; echo -e;
report_subnets_ec2_instances; echo -e;
report_subnets_metadata; echo -e;
report_subnets_subnet_route_tables; echo -e;
report_vpcs_dhcp_options; echo -e;
report_vpcs_ec2_instances; echo -e;
report_vpcs_endpoints; echo -e;
report_vpcs_igws; echo -e;
report_vpcs_metadata; echo -e;
report_vpcs_nat_gateways; echo -e;
report_vpcs_network_acls; echo -e;
report_vpcs_network_interfaces; echo -e;
report_vpcs_route_tables; echo -e;
report_vpcs_route_tables_unassociated; echo -e;
report_vpcs_security_groups; echo -e;
report_vpcs_security_groups_unattached; echo -e;
report_vpcs_transit_gateway_attachments; echo -e;
